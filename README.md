# 동시성 제어 전략

## 동시성 제어란?
동시성 제어는 다수의 프로세스나 스레드가 동일한 리소스(예: 데이터베이스, 파일, 메모리 등)에 동시에 접근하거나 작업을 수행할 때, 데이터 무결성과 시스템 안정성을 보장하기 위해 이를 관리하는 기술과 기법을 의미한다.

---

## 시스템 환경에 따른 동시성 제어 전략

### 1. 단일 서버 환경
- **전략**: 스레드 동기화 또는 데이터베이스 락
  - Java에서는 `synchronized`, `ReentrantLock` 등을 활용해 메모리 동기화.
  - 데이터베이스의 Row-Level Lock이나 Transaction을 사용.
- **예시**: 단일 서버에서 로그인 요청 처리.

### 2. 분산 서버 환경
- **전략**: 분산 락(Distributed Lock)
  - Redis의 `SETNX`, Zookeeper 등을 활용해 락을 분산 환경에서 구현.
- **예시**: 동일한 사용자에 대한 여러 서버에서의 동시 업데이트 방지.

추가 인프라 설치 없이 동시성을 보장할 수 있는 방법은 `synchronized`, `ReentrantLock` 두 가지이다.

---

## Synchronized vs ReentrantLock

### **Synchronized**
- 대기 중인 스레드가 JVM 내부 메커니즘에 의해 관리된다.
- 이 과정에서 특정 큐(대기열)에 저장된다. JVM이 이를 기반으로 스레드 간 락 획득을 제어한다.
- FIFO 기반으로 스레드 대기열을 유지하지만, 이 순서가 엄격히 준수되지 않을 수 있다.
  - 운영체제의 스케줄러 및 JVM 최적화(자원 활용)를 위해, 대기열의 순서와 상관없이 특정 스레드가 먼저 깨어날 수 있다.
- 따라서, 대기하는 스레드들의 FIFO 순서가 보장되지 않는다.

### **ReentrantLock**
- Java에서 제공하는 `java.util.concurrent.locks` 패키지의 클래스 중 하나로, 동기화를 더 세밀하게 제어하기 위해 사용된다.
- `synchronized` 키워드보다 더 많은 기능과 유연성을 제공하며, 주로 스레드 간의 동시 접근을 제어하여 동기화 문제를 방지하는 데 사용된다.
- 내부적으로 대기 중인 스레드를 관리하기 위해 **FIFO 큐**를 사용한다.
  - 락을 획득하려는 스레드는 큐에 등록되고, 락이 해제되면 큐의 맨 앞에 있는 스레드가 락을 획득하게 된다.
- 따라서, 대기하는 스레드들의 FIFO 순서가 보장된다.

---

## 사용자별 동시성과 순차성 보장

### 문제
포인트의 경우, 유저별로 종속되는 데이터라 유저 개개인의 요청에 의해서만 처리된다.
만약, 철수가 포인트 충전/사용을 여러 번 시도할 때, 영희가 첫 번째 요청임에도 철수의 작업을 기다리느라 늦어진다면 이는 비효율적이다. 영희 입장에서는 철수를 원망할 수도 있다.

### 해결 방법
- 각각의 유저들에 대해 동시성과 순차성을 보장해야 한다.
- `key`, `value` 형태인 **HashMap**을 사용하여 `userId`를 key로 하고, value로 **ReentrantLock**을 사용하면 된다.
- 단, **HashMap**은 Thread-safe하지 못하기로 유명하다. 이를 대신하여 Java에서 제공하는 **ConcurrentHashMap**을 사용한다.

---

## ConcurrentHashMap이란?
- 기존 `HashMap`을 래핑하여 동기화된 버전을 제공한 것으로, Thread-safe하다.
- 그러나, **전역 락**을 사용하므로, 동시 쓰기가 많은 경우 성능 저하가 발생할 수 있다.

---

## 결론
- 동시성과 순차성을 위해 **ReentrantLock**을 사용하되, 유저별 처리를 위해 **ConcurrentHashMap**을 함께 사용한다.

---

## 메모리 관리

### 문제
일반적으로 참조되지 않는 객체는 GC가 처리하지만, 메모리 누수나 불필요한 객체가 계속 남아 있는 문제를 방지하기 위해 다음 방법을 고려했다.

### 방법
1. **WeakHashMap 사용**
   - **장점**: 구현이 쉽다.
   - **단점**: 제거 타이밍 제어가 불가능하다.

2. **스케줄러로 LRU 삭제**
   - **장점**: 스케줄러에 의해 명시적으로 처리가 가능해 제거 타이밍이 명확하다.
   - **단점**: 구현이 복잡하고, 주기적인 스케줄러 실행으로 서버 부하가 증가할 가능성이 있다.

### 최종 선택
WeakHashMap도 좋지만, `unlock()`을 하지 않는 등 코드적인 이슈를 제어하기 위해 **스케줄러**를 사용하여 구현했다.

---

## 구현 방법

### LockWrapper
- `ReentrantLock`을 감싸면서 필드로 **최근 락 시간**을 추가로 갖는다.

### LockManager
- 락 객체를 관리하는 **ConcurrentHashMap**을 사용.
- 최근 사용 시간이 일정 시간이 넘어가면 `cleanUp` 메서드를 호출하여 삭제한다.
- `cleanUp`은 **Spring Scheduler**로 관리된다.

---

## 그 밖의 고려사항

### **Facade 패턴**
- 상위 서비스 클래스에는 "무엇을 할지"를 정의하고, 하위 서비스 클래스에는 "어떻게 할지"를 구현.
- 이 패턴을 사용하면, 비즈니스 로직과 락 관리 로직 등이 모두 캡슐화되어 장점이 있다.

### **통합 테스트 시행착오**
1. `MockMVC`를 사용하면 **Lock 동시성 테스트**가 잘되지 않을 수 있다. (안되더라..)
2. SpringMVC는 `@RequestBody`로 단순 타입을 받을 때, 직접적인 값을 요청 바디로 기대한다.
    JSON 객체 형식이 전달되면 매핑할 수 없어서 400 에러를 반환한다.

테스트 시 주의가 필요하다.
